#!/usr/bin/env ruby

require "pathname"

class Pathname
  def without_extname
    Pathname(to_s.chomp(extname))
  end
end

class Hash
  def hzip(other)
    result = {}
    each do |k,v|
      result[k] ||= [nil, nil]
      result[k][0] = v
    end
    other.each do |k,v|
      result[k] ||= [nil, nil]
      result[k][1] = v
    end
    result
  end
end

class BooksRepository
  attr_reader :path
  def initialize(path)
    @path = Pathname(path)
    raise "Invalid path `#{@path}'" unless @path.exist?
  end

  def files
    @path.find.select(&:file?).reject{|path|
      path.dirname.extname == ".sdr"
    }.map{|path| path.relative_path_from(@path)}
  end

  def file_groups
    Hash[files.group_by(&:without_extname).map do |prefix, paths|
      [prefix, paths.map(&:extname).sort]
    end]
  end

  def print!
    file_groups.sort.each do |prefix, exts|
      puts "#{prefix} (#{exts.join(" ")})"
    end
  end
end

class KindleSync
  def initialize(repo_path, device_path)
    @repo   = BooksRepository.new(repo_path)
    @device = BooksRepository.new(device_path)
  end

  def books
    @books ||= @device.file_groups.hzip(@repo.file_groups)
  end

  def synced_state?(state1, state2)
    state1 == state2
  end

  def report!
    books.sort.each do |book, (state1, state2)|
      next if synced_state?(state1, state2)
      state1_as_s = state1 ?  state1.join(" ") : "-"
      state2_as_s = state2 ?  state2.join(" ") : "-"
      puts "#{book} (#{state1_as_s} | #{state2_as_s})"
    end
  end

  def sync!
    warn "Not implemented yet"
  end
end

case [ARGV.size, ARGV[0]]
when [3, "--report"]
  ks = KindleSync.new(ARGV[1], ARGV[2])
  ks.report!
when [3, "--sync"]
  ks = KindleSync.new(ARGV[1], ARGV[2])
  ks.sync!
when [2, "--list"]
  repo = BooksRepository.new(ARGV[1])
  repo.print!
else
  STDERR.puts "Usage: #{$0} --report /repository/path /device/documents/path"
  STDERR.puts "   or: #{$0} --sync   /repository/path /device/documents/path"
  STDERR.puts "   or: #{$0} --list   /repository/path"
  exit 1
end
